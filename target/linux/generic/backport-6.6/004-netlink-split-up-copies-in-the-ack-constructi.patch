From 6125304c0a0f61044171c1aa00debdc9105e5654 Mon Sep 17 00:00:00 2001
From: Marty Jones <mj8263788@gmail.com>
Date: Mon, 7 Nov 2022 14:30:42 -0500
Subject: [PATCH] Revert "netlink: split up copies in the ack construction"

This reverts commit 738136a0e3757a8534df3ad97d6ff6d7f429f6c1.
---
 include/net/netlink.h        | 21 ---------------------
 include/uapi/linux/netlink.h |  2 --
 net/netlink/af_netlink.c     | 29 +++++++++--------------------
 3 files changed, 9 insertions(+), 43 deletions(-)

--- a/include/net/netlink.h
+++ b/include/net/netlink.h
@@ -946,27 +946,6 @@ static inline struct nlmsghdr *nlmsg_put
 }
 
 /**
- * nlmsg_append - Add more data to a nlmsg in a skb
- * @skb: socket buffer to store message in
- * @size: length of message payload
- *
- * Append data to an existing nlmsg, used when constructing a message
- * with multiple fixed-format headers (which is rare).
- * Returns NULL if the tailroom of the skb is insufficient to store
- * the extra payload.
- */
-static inline void *nlmsg_append(struct sk_buff *skb, u32 size)
-{
-	if (unlikely(skb_tailroom(skb) < NLMSG_ALIGN(size)))
-		return NULL;
-
-	if (NLMSG_ALIGN(size) - size)
-		memset(skb_tail_pointer(skb) + size, 0,
-		       NLMSG_ALIGN(size) - size);
-	return __skb_put(skb, NLMSG_ALIGN(size));
-}
-
-/**
  * nlmsg_put_answer - Add a new callback based netlink message to an skb
  * @skb: socket buffer to store message in
  * @cb: netlink callback
--- a/net/netlink/af_netlink.c
+++ b/net/netlink/af_netlink.c
@@ -2480,24 +2480,19 @@ void netlink_ack(struct sk_buff *in_skb,
 		flags |= NLM_F_ACK_TLVS;
 
 	skb = nlmsg_new(payload + tlvlen, GFP_KERNEL);
-	if (!skb)
-		goto err_skb;
+	if (!skb) {
+		NETLINK_CB(in_skb).sk->sk_err = ENOBUFS;
+		sk_error_report(NETLINK_CB(in_skb).sk);
+		return;
+	}
 
 	rep = nlmsg_put(skb, NETLINK_CB(in_skb).portid, nlh->nlmsg_seq,
-			NLMSG_ERROR, sizeof(*errmsg), flags);
-	if (!rep)
-		goto err_bad_put;
+			NLMSG_ERROR, payload, flags);
 	errmsg = nlmsg_data(rep);
 	errmsg->error = err;
-	errmsg->msg = *nlh;
-
-	if (!(flags & NLM_F_CAPPED)) {
-		if (!nlmsg_append(skb, nlmsg_len(nlh)))
-			goto err_bad_put;
-
-		memcpy(nlmsg_data(&errmsg->msg), nlmsg_data(nlh),
-		       nlmsg_len(nlh));
-	}
+	unsafe_memcpy(&errmsg->msg, nlh, payload > sizeof(*errmsg)
+					 ? nlh->nlmsg_len : sizeof(*nlh),
+		      /* Bounds checked by the skb layer. */);
 
 	if (tlvlen)
 		netlink_ack_tlv_fill(in_skb, skb, nlh, err, extack);
@@ -2505,14 +2500,6 @@ void netlink_ack(struct sk_buff *in_skb,
 	nlmsg_end(skb, rep);
 
 	nlmsg_unicast(in_skb->sk, skb, NETLINK_CB(in_skb).portid);
-
-	return;
-
-err_bad_put:
-	nlmsg_free(skb);
-err_skb:
-	NETLINK_CB(in_skb).sk->sk_err = ENOBUFS;
-	sk_error_report(NETLINK_CB(in_skb).sk);
 }
 EXPORT_SYMBOL(netlink_ack);
 
